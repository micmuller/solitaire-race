<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solitaire HighNoon</title>
  <style>
    :root { --bg:#0b1020; --felt:#0f5132; --card:#fff; --ink:#0b1020; --muted:#9aa3b2; --radius:10px; }
    html, body { height:100%; }
    body { margin:0; background: radial-gradient(1200px 800px at 50% 10%, #143b26, var(--felt)); color:#eef2ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; display:grid; grid-template-rows:auto 1fr; gap:8px; }
    header { display:flex; align-items:center; gap:12px; padding:10px 14px; background:#0b1222aa; backdrop-filter: blur(6px); border-bottom:1px solid #ffffff12; position:relative; z-index:100; }
    header h1 { font-size:18px; margin:0; letter-spacing:.3px; display:flex; align-items:center; gap:8px; }
    header .controls { margin-left:auto; display:flex; gap:8px; flex-wrap:wrap; }
    button, input { border-radius:8px; border:1px solid #ffffff22; background:#0b1222; color:#e5e7eb; padding:8px 10px; }
    button.primary { background:#1f2937; border-color:#ffffff33; }
    .badge { font-size:12px; padding:2px 8px; border-radius:999px; background:#ffffff14; border:1px solid #ffffff22; }

    .board { display:grid; grid-template-columns:1fr minmax(260px,520px) 1fr; gap:14px; padding:14px; position:relative; z-index:1; }
    .col { display:grid; grid-template-rows:auto 1fr; gap:10px; }
    .zone-title { font-size:12px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted); }

    .row { display:flex; gap:10px; align-items:flex-start; }
    .stack, .pile, .foundation { width:86px; height:120px; border-radius:var(--radius); background:#00000022; border:1px dashed #ffffff2a; position:relative; flex:0 0 auto; }
    .pile { min-width:86px; }
    .tableau { display:flex; gap:10px; }

    .card { width:86px; height:120px; border-radius:var(--radius); background:var(--card); color:var(--ink); position:absolute; top:0; left:0; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:22px; user-select:none; box-shadow:0 6px 14px #00000055; border:1px solid #0b102022; z-index:5; }
    .card.red { color:#b91c1c; }
    .card.black { color:#0b1020; }
    .card.faceDown { background: linear-gradient(135deg, #172554, #1e293b); color:#e5e7eb; border-color:#0ea5e9; box-shadow:0 6px 14px #0006 inset; }
    .card.dragging { transform: scale(1.06) rotate(-2deg); z-index:999; box-shadow:0 14px 30px #00000088; }

    .foundations { display:grid; grid-template-columns: repeat(4, 86px); gap:10px; justify-content:center; }
    .foundations .foundation::after { content: attr(data-suit); position:absolute; bottom:6px; right:8px; font-size:18px; opacity:.35; }

    .hint { font-size:12px; color:#cbd5e1; opacity:.8; }
    .toast { position:fixed; right:14px; bottom:14px; background:#0b1222; border:1px solid #ffffff22; padding:10px 12px; border-radius:10px; opacity:0; transform: translateY(12px); transition:.25s ease; }
    .toast.show { opacity:1; transform: translateY(0); }
    .divider { height:1px; background:#ffffff15; margin:8px 0; }
    .opponent { opacity:.92; }
    .small { font-size:11px; color:#9aa3b2; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#111827; padding:1px 6px; border-radius:6px; border:1px solid #ffffff22; }

    /* Status Overlay */
    .overlay { position:fixed; bottom:12px; right:12px; z-index:50; min-width:220px; background:#0b1222cc; border:1px solid #ffffff22; border-radius:12px; padding:10px 12px; box-shadow:0 6px 20px #0008; }
    .overlay h3 { margin:0 0 6px; font-size:13px; letter-spacing:.08em; text-transform:uppercase; color:#cbd5e1; }
    .overlay .kv { display:grid; grid-template-columns:110px 1fr; gap:6px 8px; font-size:12px; }
    .dot { display:inline-block; width:8px; height:8px; border-radius:999px; background:#ef4444; vertical-align:middle; margin-right:6px; }
    .dot.ok { background:#22c55e; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    @media (max-width:1100px){ .board { grid-template-columns:1fr; } }
  </style>
</head>
<body>
  <header>
    <h1>
      Solitaire HighNoon
      <span class="badge" id="ver">v?</span>
    </h1>
    <div class="controls">
      <input id="room" placeholder="Room-ID" title="Room/Match ID" />
      <input id="seed" placeholder="Seed (optional)" title="Deterministische Mischung" />
      <button id="newGame" class="primary">Neu starten</button>
      <button id="connect">Verbinden</button>
      <span class="small">Aktionen: <span id="moves">0</span></span>
      <span class="small">Sync: <span id="syncState">offline</span></span>
    </div>
  </header>

  <div class="overlay" id="overlay">
    <h3>Status</h3>
    <div class="kv">
      <div>Sync</div><div><span class="dot" id="dot"></span><span id="ov-sync">offline</span></div>
      <div>Room</div><div class="mono" id="ov-room">—</div>
      <div>Seed</div><div class="mono" id="ov-seed">—</div>
      <div>Peers</div><div id="ov-peers">0</div>
      <div>Latency</div><div id="ov-latency">—</div>
      <div>Last msg</div><div id="ov-last">—</div>
      <div>Version</div><div id="ov-version">—</div>
    </div>
  </div>

  <main class="board" id="board">
    <section class="col" id="youCol">
      <div class="row">
        <div>
          <div class="zone-title">Dein Stock/Waste</div>
          <div class="row">
            <div class="stack" id="you-stock"></div>
            <div class="stack" id="you-waste"></div>
          </div>
        </div>
      </div>
      <div>
        <div class="zone-title">Deine 7 Tableaus</div>
        <div class="tableau" id="you-tableau"></div>
      </div>
    </section>

    <section>
      <div class="zone-title" style="text-align:center">Gemeinsame Foundations (8 Stapel, 2×♥♦♣♠)</div>
      <div class="foundations" id="foundations"></div>
      <div class="hint" style="text-align:center;margin-top:8px;">Sequenz-Moves, Auto-Move (Doppelklick), Recycle (Waste→Stock).</div>
      <div class="divider"></div>
    </section>

    <section class="col opponent" id="oppCol">
      <div class="row">
        <div>
          <div class="zone-title">Gegner Stock/Waste</div>
          <div class="row">
            <div class="stack" id="opp-stock"></div>
            <div class="stack" id="opp-waste"></div>
          </div>
        </div>
      </div>
      <div>
        <div class="zone-title">Gegner 7 Tableaus</div>
        <div class="tableau" id="opp-tableau"></div>
      </div>
    </section>
  </main>

  <div class="toast" id="toast"></div>


<script>
/* ============================================================
   Solitaire HighNoon — v2.7.5
   - FIX: deterministische Spiegelung über Ziel-Seite (you/opp), nicht via owner==localOwner
   - FIX: Perspektive (you/opp) wird nur einmal gesetzt (race-safe hello)
   - Beibehalt: owner-relatives Protokoll (to/from), opp-Rendering gespiegelt,
                Auto-Reconnect, Ping/Pong, Shortcuts, dyn. Version
   ============================================================ */
(function(){
  const VERSION = '2.7.5';

  // ---------- Helpers ----------
  function showToast(msg){
    const t=document.getElementById('toast'); if(!t) return;
    t.textContent=msg; t.classList.add('show');
    setTimeout(()=>t.classList.remove('show'),1800);
  }
  const url=new URL(location.href);

  // RNG
  function rng(seedStr){
    function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0;};}
    function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;};}
    const seed=xmur3(seedStr||'')(); return { random:mulberry32(seed) };
  }

  // Cards
  const SUITS=["♠","♥","♦","♣"];
  const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  function newDoubleDeck(tag){
    const deck=[];
    for(let d=0;d<2;d++){
      for(const s of SUITS){
        for(let r=0;r<RANKS.length;r++){
          deck.push({suit:s,rank:r,up:false,id:`${tag}-${d}-${s}-${r}`});
        }
      }
    }
    return deck;
  }
  function shuffle(a,r){const arr=a.slice();for(let i=arr.length-1;i>0;i--){const j=Math.floor(r()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;}
  function rankStr(i){return RANKS[i];}
  function isRed(s){return s==="♥"||s==="♦";}
  function cardLabel(c){return `${rankStr(c.rank)}${c.suit}`;}

  // ---------- State ----------
  const state={
    seed:url.searchParams.get('seed')||'',
    room:url.searchParams.get('room')||'',
    you:{stock:[],waste:[],tableau:[[],[],[],[],[],[],[]]},
    opp:{stock:[],waste:[],tableau:[[],[],[],[],[],[],[]]},
    foundations:Array.from({length:8},(_,i)=>({suit:SUITS[i%4],cards:[]})),
    moves:0,over:false
  };

  // ---------- Owner & Mapping ----------
  let localOwner='Y';
  let hasSetPerspective=false; // NEU: verhindert Doppel-Swap
  function ownerToSide(owner){return owner===localOwner?'you':'opp';}
  const PILES=7;
  function mapOwnerPileToLocal(p, ownerRef){
    // Mappe owner-relativen Pile p auf die lokale Datenstruktur,
    // abhängig davon, ob der ownerRef bei mir 'you' oder 'opp' ist.
    const side = ownerToSide(ownerRef); // 'you' oder 'opp'
    return side==='you' ? p : (PILES-1-p);
  }

  // ---------- Deal ----------
  function deal(seedStr){
    const r=rng(seedStr||'');
    const base=shuffle(newDoubleDeck('B'),r.random);
    const deckYou=[],deckOpp=[];
    for(let i=0;i<base.length;i++){
      const c={...base[i]};
      if(i%2===0){c.id=`Y-${i}-${c.suit}-${c.rank}`;deckYou.push(c);}
      else{c.id=`O-${i}-${c.suit}-${c.rank}`;deckOpp.push(c);}
    }
    let i=0;
    for(let p=0;p<7;p++){for(let k=0;k<=p;k++){const c=deckYou[i++];c.up=(k===p);state.you.tableau[p].push(c);}}
    state.you.stock=deckYou.slice(i);
    i=0;
    for(let p=0;p<7;p++){for(let k=0;k<=p;k++){const c=deckOpp[i++];c.up=(k===p);state.opp.tableau[p].push(c);}}
    state.opp.stock=deckOpp.slice(i);
  }

  // ---------- DOM ----------
  const el=s=>document.querySelector(s);
  const mk=(t,c)=>{const e=document.createElement(t);if(c)e.className=c;return e;};

  function renderAll(){
    const mv=document.getElementById('moves'); if(mv) mv.textContent=String(state.moves);

    // clear
    ['you','opp'].forEach(side=>{
      el(`#${side}-tableau`)?.replaceChildren();
      el(`#${side}-stock`)?.replaceChildren();
      el(`#${side}-waste`)?.replaceChildren();
    });
    el('#foundations')?.replaceChildren();

    // foundations
    state.foundations.forEach((f,i)=>{
      const slot=mk('div','foundation'); slot.dataset.f=i; el('#foundations')?.appendChild(slot);
      f.cards.forEach((c,idx)=>{const card=renderCard(c);card.style.top=`${idx*2}px`;slot.appendChild(card);});
    });

    // stacks
    renderStack('you'); renderStack('opp');

    // tableaux (Gegner gespiegelt)
    ['you','opp'].forEach(side=>{
      const cont=el(`#${side}-tableau`); if(!cont) return;
      const indices = side==='opp' ? [...Array(PILES).keys()].reverse()
                                   : [...Array(PILES).keys()];
      for(const p of indices){
        const pileEl=mk('div','pile');
        pileEl.dataset.zone=`${side}-pile-${p}`;
        cont.appendChild(pileEl);
        const pile=state[side].tableau[p];
        pile.forEach((c,idx)=>{const card=renderCard(c);card.style.top=`${idx*24}px`;pileEl.appendChild(card);});
      }
    });

    setupDrops();
    updateOverlay();
  }

  function renderStack(side){
    const stockEl=el(`#${side}-stock`); const wasteEl=el(`#${side}-waste`);
    const s=state[side].stock;
    if(stockEl && s.length){const top=s[s.length-1]; const back=renderCard({...top,up:false}); stockEl.appendChild(back);}
    if(wasteEl){
      state[side].waste.slice(-3).forEach((c,i)=>{const card=renderCard(c);card.style.left=`${i*16}px`;wasteEl.appendChild(card);});
    }
  }

  function renderCard(c){
    const e=mk('div','card');
    if(!c.up) e.classList.add('faceDown');
    else { e.classList.add(isRed(c.suit)?'red':'black'); e.textContent=cardLabel(c); }
    e.draggable=!!c.up; e.dataset.cardId=c.id;
    e.addEventListener('dragstart',onDragStart);
    e.addEventListener('dragend',onDragEnd);
    e.addEventListener('dblclick',onDoubleClickAutoMove);
    return e;
  }

  // ---------- Rules ----------
  function canPlaceOnTableau(under,card){ if(!under) return card.rank===12; const alt=isRed(under.suit)!==isRed(card.suit); return under.rank===card.rank+1&&alt; }
  function canPlaceOnFoundation(f,card){ if(f.cards.length===0) return card.rank===0; const top=f.cards[f.cards.length-1]; return top && top.suit===card.suit && card.rank===top.rank+1; }
  function locOfCard(id){
    for(const side of ['you','opp']){
      const w=state[side].waste.findIndex(c=>c.id===id); if(w>-1) return {type:'waste',side,idx:w};
      for(let p=0;p<7;p++){const idx=state[side].tableau[p].findIndex(c=>c.id===id); if(idx>-1) return {type:'pile',side,pile:p,idx};}
    }
    for(let f=0;f<state.foundations.length;f++){const idx=state.foundations[f].cards.findIndex(c=>c.id===id); if(idx>-1) return {type:'found',f,idx};}
    return null;
  }
  function isFaceUpSequence(side,pileIndex,startIdx){
    const pile=state[side].tableau[pileIndex];
    for(let i=startIdx;i<pile.length-1;i++){
      const a=pile[i],b=pile[i+1];
      if(!a.up||!b.up) return false;
      if(isRed(a.suit)===isRed(b.suit)) return false;
      if(a.rank!==b.rank+1) return false;
    }
    return pile[startIdx]?.up===true;
  }

  // ---------- Drag & Drop ----------
  let drag={origin:null,count:1};
  function isMine(loc){ return loc && loc.side === ownerToSide(localOwner); }

  function onDragStart(e){
    const id=e.target.dataset.cardId; const loc=locOfCard(id);
    drag.origin=null; drag.count=1;
    if(!isMine(loc)){ e.preventDefault(); return; }
    drag.origin=loc;
    e.dataTransfer.setData('text/plain',id);
    e.target.classList.add('dragging');
    if(loc?.type==='pile'){
      const pile=state[loc.side].tableau[loc.pile];
      if(isFaceUpSequence(loc.side,loc.pile,loc.idx)) drag.count=pile.length-loc.idx;
    }
  }
  function onDragEnd(e){ e.target.classList.remove('dragging'); }

  function onDoubleClickAutoMove(e){
    const id=e.currentTarget.dataset.cardId; const loc=locOfCard(id); if(!loc) return;
    if(!isMine(loc)) return;
    let card;
    if(loc.type==='pile'){
      const pile=state[loc.side].tableau[loc.pile]; if(loc.idx!==pile.length-1) return; card=pile[loc.idx];
    } else if(loc.type==='waste'){
      if(loc.idx!==state[loc.side].waste.length-1) return; card=state[loc.side].waste[loc.idx];
    } else return;
    const t=state.foundations.findIndex(f=>canPlaceOnFoundation(f,card));
    if(t>-1) applyMove({owner:localOwner,kind:'toFound',cardId:id,count:1,to:{kind:'found',f:t}},true);
  }

  function setupDrops(){
    // Foundations
    document.querySelectorAll('.foundation').forEach(slot=>{
      slot.addEventListener('dragover',ev=>ev.preventDefault());
      slot.addEventListener('drop',ev=>{
        ev.preventDefault();
        const id=ev.dataTransfer.getData('text/plain'); const loc=locOfCard(id); if(!loc||!isMine(loc)) return;
        const fIdx=Number(slot.dataset.f); const f=state.foundations[fIdx];
        const card=(loc.type==='waste')?state[loc.side].waste[loc.idx]
                  :(loc.type==='pile'?state[loc.side].tableau[loc.pile][loc.idx]
                                      :state.foundations[loc.f].cards[loc.idx]);
        if(card&&canPlaceOnFoundation(f,card)){
          applyMove({owner:localOwner,kind:'toFound',cardId:id,count:1,to:{kind:'found',f:fIdx}},true);
        }
      });
    });

    // Nur eigene Piles droppbar
    const mySide = ownerToSide(localOwner);
    for(let p=0;p<7;p++){
      const pileEl=document.querySelector(`[data-zone="${mySide}-pile-${p}"]`);
      if(!pileEl) continue;
      pileEl.addEventListener('dragover',ev=>ev.preventDefault());
      pileEl.addEventListener('drop',ev=>{
        ev.preventDefault();
        const id=ev.dataTransfer.getData('text/plain'); const loc=locOfCard(id); if(!loc||!isMine(loc)) return;
        const destPile=state[mySide].tableau[p];
        const under=destPile[destPile.length-1];
        const srcTop=(loc.type==='waste')?state[loc.side].waste[loc.idx]:state[loc.side].tableau[loc.pile][loc.idx];
        if(!srcTop?.up) return;
        if(canPlaceOnTableau(under,srcTop)){
          const count=(loc.type==='pile'&&isFaceUpSequence(loc.side,loc.pile,loc.idx))?state[loc.side].tableau[loc.pile].length-loc.idx:1;
          applyMove({
            owner: localOwner,
            kind: 'toPile',
            cardId: id,
            count,
            from: { kind:'pile', sideOwner: localOwner, pile: loc.pile }, // owner-relativ
            to:   { kind:'pile', sideOwner: localOwner, pile: p }         // owner-relativ
          }, true);
        }
      });
    }

    // Klick/Shortcuts
    const myStock = el(`#${mySide}-stock`);
    const myWaste = el(`#${mySide}-waste`);
    if(myStock) myStock.onclick=()=>{ const s=state[mySide].stock; if(s.length) applyMove({owner:localOwner,kind:'flip'},true); };
    if(myWaste) myWaste.ondblclick=()=>{ if(state[mySide].stock.length===0 && state[mySide].waste.length>0) applyMove({owner:localOwner,kind:'recycle'},true); };

    document.onkeydown=(ev)=>{
      if(state.over) return;
      const side=ownerToSide(localOwner);
      if(ev.key===' '){ ev.preventDefault(); const s=state[side].stock; if(s.length) applyMove({owner:localOwner,kind:'flip'},true); }
      else if(ev.key==='r' || ev.key==='R'){ if(state[side].stock.length===0 && state[side].waste.length>0) applyMove({owner:localOwner,kind:'recycle'},true); }
      else if(ev.key==='f' || ev.key==='F'){
        const w=state[side].waste; if(!w.length) return;
        const card=w[w.length-1];
        const t=state[side].foundations.findIndex(f=>canPlaceOnFoundation(f,card));
        if(t>-1) applyMove({owner:localOwner,kind:'toFound',cardId:card.id,count:1,to:{kind:'found',f:t}},true);
      }
    };
  }

  // ---------- Moves ----------
  function applyMove(move,announce=true){
    try{
      const side=ownerToSide(move.owner);
      if(move.kind==='flip'){
        const s=state[side].stock;
        if(s.length){ const c=s.pop(); c.up=true; state[side].waste.push(c); }
        if(announce) state.moves++;
        renderAll(); if(announce) send(move); return;
      }
      if(move.kind==='recycle'){
        if(state[side].stock.length===0 && state[side].waste.length>0){
          const rev=[...state[side].waste].reverse(); rev.forEach(c=>c.up=false);
          state[side].stock = rev; state[side].waste = [];
        }
        if(announce) state.moves++;
        renderAll(); if(announce) send(move); return;
      }

      const loc=move.cardId?locOfCard(move.cardId):null; if(!loc) return;
      if(announce && loc.side !== ownerToSide(move.owner)) return;

      if(!announce) console.debug('[NET] move', move);

      let cards=[];
      if(loc.type==='waste'){
        if(loc.idx!==state[loc.side].waste.length-1) return;
        cards.push(state[loc.side].waste.pop());
      } else if(loc.type==='pile'){
        const pile=state[loc.side].tableau[loc.pile];
        const count=move.count||1; cards=pile.splice(loc.idx,count);
        if(pile.length>0) pile[pile.length-1].up=true;
      } else if(loc.type==='found'){
        if(loc.idx!==state.foundations[loc.f].cards.length-1) return;
        cards.push(state.foundations[loc.f].cards.pop());
      }
      if(cards.length===0) return;

      if(move.to && move.to.kind==='found'){
        state.foundations[move.to.f].cards.push(cards[0]);
      } else if(move.to && move.to.kind==='pile'){
        const ownerRef = move.to.sideOwner || move.owner; // 'Y'|'O'
        const targetSide = ownerToSide(ownerRef);          // 'you'|'opp'
        const targetPile = mapOwnerPileToLocal(move.to.pile, ownerRef); // p oder 6-p
        // optional: Plausibilitätslog der Quelle
        if(move.from && move.from.kind==='pile'){
          const fromOwner=move.from.sideOwner||move.owner;
          const expectedFromSide = ownerToSide(fromOwner);
          const expectedFromPile = mapOwnerPileToLocal(move.from.pile, fromOwner);
          if(loc.side!==expectedFromSide || loc.type!=='pile' || loc.pile!==expectedFromPile){
            console.debug('[NET] source mismatch (non-fatal)', {loc, expectedFromSide, expectedFromPile});
          }
        }
        state[targetSide].tableau[targetPile].push(...cards);
      }
      if(announce) state.moves++;
      renderAll(); if(announce) send(move);
      checkWin();
    }catch(err){
      console.error('applyMove error',err);
      showToast('Move-Fehler: '+(err?.message||String(err)));
    }
  }

  function checkWin(){
    const total=state.foundations.reduce((a,f)=>a+f.cards.length,0);
    if(total===208){ state.over=true; showToast('Alle Karten abgetragen!'); }
  }

  // ---------- WS ----------
  const peers=new Map();
  let clientId=Math.random().toString(36).slice(2);
  let ws=null, pingTimer=null, lastMsgAt=0, latencyMs=null;
  let reconnectAttempts=0, reconnectTimer=null;

  function setText(id,txt){ const n=document.getElementById(id); if(n) n.textContent=txt; }
  function updateOverlay(){
    const online = ws && ws.readyState===1;
    const dot=document.getElementById('dot');
    const ovSync=document.getElementById('ov-sync');
    if(dot) dot.classList.toggle('ok', !!online);
    if(ovSync) ovSync.textContent = online ? 'online' : 'offline';
    setText('ov-room', state.room||'—');
    setText('ov-seed', state.seed||'—');
    setText('ov-peers', String(peers.size));
    setText('ov-latency', latencyMs!=null ? `${Math.max(0,Math.round(latencyMs))} ms` : '—');
    setText('ov-last', lastMsgAt>0 ? (Math.floor((Date.now()-lastMsgAt)/1000)||0)+'s ago' : '—');
    setText('ov-version', VERSION);
  }

  setInterval(()=>{
    const now=Date.now();
    for(const [id,ts] of peers){ if(now-ts>15000) peers.delete(id); }
    updateOverlay();
  }, 1000);

  function sendSys(o){ if(ws&&ws.readyState===1) ws.send(JSON.stringify({sys:o,from:clientId})); }
  function send(m){ if(ws&&ws.readyState===1) ws.send(JSON.stringify({move:m,from:clientId})); }

  function buildWsUrl(){
    const override=url.searchParams.get('ws'); if(override) return override;
    const isHttps=location.protocol==='https:'; const proto=isHttps?'wss:':'ws:';
    const host=location.hostname||'127.0.0.1';
    const currentPort=(location.port?parseInt(location.port,10):(isHttps?443:80));
    const wsPort=url.searchParams.get('ws_port') || (currentPort===3001?3001:(isHttps?443:3001));
    return `${proto}//${host}:${wsPort}/ws?room=${encodeURIComponent(state.room.trim())}`;
  }

  function clearWsTimers(){ if(pingTimer){clearInterval(pingTimer); pingTimer=null;} if(reconnectTimer){clearTimeout(reconnectTimer); reconnectTimer=null;} }
  function scheduleReconnect(){
    clearWsTimers();
    const base=5000,max=30000,delay=Math.min(max, base*Math.pow(1.7,reconnectAttempts++));
    reconnectTimer=setTimeout(()=>{connectWS();},delay);
  }

  function connectWS(){
    const room=state.room.trim(); if(!room){ showToast('Room-ID fehlt'); return; }
    const wsUrl=buildWsUrl();
    try{ ws=new WebSocket(wsUrl); }catch(e){ console.error('WS open error',e); scheduleReconnect(); return; }

    ws.onopen=()=>{
      showToast('Verbunden'); reconnectAttempts=0;
      sendSys({type:'hello'});
      updateOverlay(); clearWsTimers();
      pingTimer=setInterval(()=>{ if(ws&&ws.readyState===1){ const ts=Date.now(); sendSys({type:'ping', ts}); } },5000);
    };
    ws.onclose=()=>{ showToast('Getrennt'); clearWsTimers(); updateOverlay(); scheduleReconnect(); };
    ws.onerror=(err)=>{ console.error('WS error',err); updateOverlay(); };

    ws.onmessage=(ev)=>{
      lastMsgAt=Date.now();
      try{
        const msg=JSON.parse(ev.data);
        if(msg.from) peers.set(msg.from, Date.now());

        if(msg.sys){
          if(msg.sys.type==='hello' && msg.from){
            // stabile Zuordnung nur einmal
            if(!hasSetPerspective){
              const iAmY = clientId.localeCompare(msg.from) < 0;
              const desired = iAmY ? 'Y' : 'O';
              if(localOwner!==desired){
                localOwner=desired;
                [state.you, state.opp] = [state.opp, state.you];
                renderAll();
                showToast('Perspektive: '+localOwner);
              }else{
                localOwner=desired;
              }
              hasSetPerspective=true;
            }
            if(msg.from !== clientId){ sendSys({type:'hello-ack', from: clientId}); }
          } else if(msg.sys.type==='ping' && typeof msg.sys.ts==='number'){
            sendSys({type:'pong', ts: msg.sys.ts});
          } else if(msg.sys.type==='pong' && typeof msg.sys.ts==='number'){
            latencyMs = Date.now() - msg.sys.ts;
          }
          updateOverlay();
          return;
        }

        if(msg.move) applyMove(msg.move, false);
        updateOverlay();
      }catch(e){ console.error('WS-Error', e); }
    };
  }

  // ---------- Boot ----------
  function newGame(){
    state.you={stock:[],waste:[],tableau:[[],[],[],[],[],[],[]]};
    state.opp={stock:[],waste:[],tableau:[[],[],[],[],[],[],[]]};
    state.foundations=Array.from({length:8},(_,i)=>({suit:SUITS[i%4],cards:[]}));
    state.moves=0; state.over=false;
    deal(state.seed||''); renderAll();
  }

  window.addEventListener('DOMContentLoaded',()=>{
    const seedIn=el('#seed'), roomIn=el('#room');
    if(seedIn) seedIn.value=state.seed;
    if(roomIn) roomIn.value=state.room;
    el('#newGame')?.addEventListener('click',()=>{
      state.seed=(seedIn?.value||'').trim();
      url.searchParams.set('seed',state.seed); history.replaceState({},'',url);
      newGame();
    });
    el('#connect')?.addEventListener('click',()=>{
      state.room=(roomIn?.value||'').trim();
      url.searchParams.set('room',state.room); history.replaceState({},'',url);
      connectWS();
    });
    // Version in UI
    const setText=(id,txt)=>{ const n=document.getElementById(id); if(n) n.textContent=txt; };
    setText('ov-version', VERSION);
    setText('ver', 'v'+VERSION);
    document.title = `Solitaire HighNoon — v${VERSION}`;

    newGame();
  });
})();
</script>

</body>
</html>
