# Handoff – 2026-01-18 – Solitaire HighNoon (P1 iOS↔iOS / iOS↔BOT)

## Ziel des Tages
P1 stabilisieren für **iOS↔iOS** und **iOS↔BOT**: Fokus auf „0UNK / W-FLIP-UNK…“ Bug und Flip-Intent Hardening, ohne PWA zu berücksichtigen.

---

## 1) Beobachtete Symptome (heute)
- Auf dem **Waste** erscheint häufig eine „leere“ Karte mit Bezeichnung **0UNK**.
- In Snapshots tauchen IDs auf wie:
  - `W-FLIP-UNK-<UUID>` (faceUp:false)
- Das trat nach dem P1-mini Echo/MoveId-Verhalten deutlich **häufiger** auf als zuvor (vorher sporadisch 2–3× pro Spiel).

### Klare Evidenz aus Logs
- Server sieht wiederholt `flip`-Moves **ohne `cardId`**:
  - `{"count":1,"from":{"kind":"stock"...},"kind":"flip","to":{"kind":"waste"...},"wasteCount":...,"stockCount":...}` **(kein cardId)**
- iOS RX/Apply materialisiert dann „Unknown/Placeholder“ Karten (`W-FLIP-UNK…`) → UI zeigt **0UNK**.

➡️ Root Cause: **flip ohne cardId** + Client-Apply erstellt UNK-Karten.

---

## 2) Server-Fix (Sicherheitsnetz)
### Patch in `server.js`
**Guard:** `flip` ohne `cardId` wird serverseitig **gedroppt** und triggert einen Snapshot-Request.

Verhalten:
- Wenn `move.kind === 'flip' && !move.cardId`:
  - log: `[P1] DROP flip-without-cardId ... reason=flip_missing_cardId`
  - `state_request` wird ausgelöst
  - Move wird **nicht** broadcastet

Zusätzlich:
- `[MOVE-PAYLOAD]` Log markiert jetzt `(!) flip missing cardId`

Ziel:
- Kein Verteilen von „kaputten flips“ mehr → sofortige Eindämmung von 0UNK.

---

## 3) iOS Fixes (Hauptfix: Ursache entfernen)
### A) `WebSocketManager.swift` – Hardening
1) **Outbound-Flip**: In `send(json:)` wird für `flip` ohne `cardId` versucht, `you.stock.last?.id` zu setzen.  
   - Wenn plausibel → `cardId` wird ergänzt.
   - Wenn nicht plausibel → Flip wird **nicht gesendet**, stattdessen `state_request` (Resync).

2) **Inbound Apply**: In `applyFlip(...)` wird bei fehlender `cardId` **keine** `W-FLIP-UNK-...` Karte mehr erzeugt (keine Materialisierung von UNK).

3) **Placeholder-IDs entschärft**:
   - `S-UNK-*` / `W-UNK-*` wurden auf `P-UNK-?-?-<uuid>` umgestellt, um UI/Parsing-Effekte zu minimieren.

### B) `GameView.swift` – Zentraler P1 Flip-Sender (UIKit + SwiftUI)
- In `handleUIKitMove` bei `.drawFromHostStock`:
  - ruft jetzt `sendFlipOrRecycleP1()` (statt direkt `ws.sendFlipOrRecycle()`).

- `sendFlipOrRecycleP1()` (neu, im `GameView` Scope):
  - nimmt `topId = ws.you.stock.last?.id`
  - validiert Plausibilität (Owner Y/O, Format, kein UNK)
  - sendet `flip` **immer mit `cardId`**
  - setzt `meta.moveId`, `meta.seq`, optional `meta.baseRev`
  - falls topId fehlt/invalid → DROP und `state_request`

- SwiftUI Stock-Tap Routing:
  - `BoardLayoutView` hat jetzt `onHostStockTapP1: (() -> Void)`
  - `StockWasteRowView` nutzt `onHostStockTapP1?()` statt direktem WS-Call
  - `GameView` übergibt: `onHostStockTapP1: { sendFlipOrRecycleP1() }`

**Wichtig:** Ein initialer Compile-Fehler wurde behoben, weil `BoardLayoutView(...)` am Callsite im `GameView.body` den neuen Parameter brauchte.

---

## 4) Ergebnis / Erwarteter Effekt
- **0UNK sollte verschwinden**, weil:
  - iOS keine flips ohne `cardId` mehr sendet (GameView + WS hardening)
  - iOS bei fehlender `cardId` keine UNK-Karte mehr materialisiert
  - Server kaputte flips zusätzlich abfängt und resync erzwingt

- Drift-Risiko sinkt weiter:
  - Flip ist deterministischer, da `cardId` explizit ist
  - Snapshot-Resync bei Unsicherheit statt „blindem flip“

---

## 5) Tests (Minimal)
### iOS ↔ iOS
1) Match starten, 30–60 Sekunden **Stock spam** (schnelles flippen)
2) Erwartung:
   - keine „0UNK“ im Waste
   - im iOS-Log: `[P1] SEND flip cardId=...`
   - server log: idealerweise keine `[P1] DROP flip-without-cardId` mehr (oder nur bei echten Out-of-sync Momenten)

### iOS ↔ BOT
1) Bot-Match starten, wieder Stock spam + Waste→Foundation
2) Erwartung:
   - keine UNK / 0UNK
   - korrekte Waste/Stock Counts nach Snapshots

---

## 6) Offene Punkte / Next Steps (inkl. Zielbild Server-Authoritative)

### Kurzfristig (P1 Abschluss – iOS Fokus)
1) **Regression-Check**
   - Waste → Foundation Anzeige-Glitch (Sender sieht Karte nicht sofort)
   - Prüfen, ob durch P1-Resync (`state_request`) stabilisiert
2) **Server tmp-log Review**
   - Verifizieren, ob noch `flip` ohne `cardId` ankommen
   - Falls ja: Quelle identifizieren (UIKit / SwiftUI / Bot)
3) **P1-Abnahme**
   - Kriterien:
     - keine `0UNK` / `W-FLIP-UNK-*`
     - kein reproduzierbarer Drift iOS↔iOS / iOS↔BOT
   - Danach: P1 als *stabil* markieren

---

### Mittelfristig (P2 – Übergang zu Server-Authoritative State)
Ziel: **Single Source of Truth = Server**, Clients senden nur Intents.

**Schrittweiser Übergang (kompatibel, kein Big Bang):**

1) **Server validiert & applied Moves**
   - Clients senden nur:
     - `intent` (move)
     - `moveId`, `seq`, optional `baseRev`
   - Server entscheidet:
     - gültig → apply + broadcast
     - ungültig → reject + snapshot

2) **matchRev als harte Ordnungsgröße**
   - Jede State-Änderung erhöht `matchRev`
   - Clients:
     - akzeptieren nur `rev >= localRev`
     - erkennen sofort Stale / Out-of-Order States

3) **Snapshots first, Deltas später**
   - Phase 1:
     - Nach jedem Move optional `STATE_SNAPSHOT`
   - Phase 2:
     - `MOVE_ACK`, `MOVE_REJECT`
     - `STATE_PATCH` (Delta statt Full Snapshot)

---

### Langfristig (P3 – Voll server-authoritativ)
1) **Deck Ownership vollständig auf Server**
   - Shuffle
   - Deal
   - Recycle
   - Kein Client erzeugt Karten oder IDs

2) **Bot = normaler Server-Client**
   - Kein eigener Game-State
   - Bot benutzt exakt dieselbe Validierungs-Pipeline

3) **Anti-Drift Architektur**
   - Client-State ist rein abgeleitet
   - Optimistic UI nur kosmetisch
   - Server-State überschreibt immer

4) **Observability**
   - Server Logs:
     - matchId, moveId, seq, baseRev, matchRev
   - Debug-Overlay im Client:
     - lastSnapshotRev
     - pendingMoves
     - connectionState

---

### Architektur-Leitlinie (dauerhaft)
> **Determinism > UI Convenience**  
> **Protocol Stability > schnelle Fixes**  
> **Server Authority > Client Optimism**

Dieser Plan bleibt bewusst **parallel** zu Bugfixing aktiv, um zu vermeiden,
dass erneut Zeit in Client-seitige Symptombehandlung investiert wird.
---

## Files touched (heute)
- `server.js` (P1 guard: drop flip ohne cardId + logging)
- `WebSocketManager.swift` (flip TX enforcement + applyFlip no-UNK + placeholder ids)
- `GameView.swift`
  - `sendFlipOrRecycleP1()` + Plausibility check
  - `.drawFromHostStock` routed to P1 sender
  - `BoardLayoutView` / `StockWasteRowView` callback plumbing (`onHostStockTapP1`)
  - Callsite fix in `GameView.body` (fehlender Param)

  